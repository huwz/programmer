内容协商
========

阿帕奇 ``httpd`` 服务器支持内容协商，``HTTP/1.1`` 说明书对内容协商有详细介绍。
内容协商可以根据浏览器对媒体类型，语言，字符集以及编码方式等方面的不同偏好，选用最好的方式显示资源。
它还具有若干特性，针对浏览器发送的协商信息内容不全的请求，采取更加智能的方式进行解析。

内容协商功能由模块 ``mod_negotiation`` 实现，默认情况下该模块在服务器编译的时候静态加载。

关于内容协商
------------

资源有多种不同的显示方式，比如使用不同语言或不同媒体类型或它们之间的组合。
如何选择更合适的显示方式呢？
一种方法是向用户提供目录列表，由用户自己选择。
但通常都是由服务器自动选择的，只要浏览器在每个请求中添加相关信息，表明它对资源显示方式的偏好就可以了。
例如，某个浏览器更希望看到用法语表述的文字信息，不行的话才用英语表述。
浏览器将他们的偏好放在请求头中。
如果要求仅用法语表述，则浏览器需要在请求头中加上 ``Accept-Language: fr``。
注意，这种偏好设置，只用于需要从多个不同语言的表示形式中挑选一个的场合。

一个更复杂的请求示例：浏览器可以接受法语和英语，但是偏向于法语。
接受多种媒体类型，与普通文本或者其他文本类型相比，更偏向于 HTML 类型。
与其他媒体类型相比，更偏向于 GIF 或 JPEG 图片，当然没有选择余地时，才选择剩下的类型。

.. code-block:: HTML

 Accept-Language: fr; q=1.0, en; q=0.5
 Accept: text/html; q=1.0, text/*; q=0.8, image/gif; q=0.6, image/jpeg; q=0.6, image/*; q=0.5, */*; q=0.1

``httpd`` 支持由“服务器驱动”的内容协商，关于这点，在 ``HTTP/1.1`` 说明书中有具体定义。
它完全支持在请求头中加上 ``Accept``, ``Accept-Language``, ``Accept-Charset`` 以及 ``Accept-Encoding`` 设置。
``httpd`` 也支持半透明的内容协商；半透明内容协商还处在实验阶段，``RFC 2295/2296`` 协议标准对它进行了定义。
但 ``httpd`` 不支持这些协议中定义的“特征协商”。

资源是 URI 指定的概念化实体。
HTTP 服务器，如阿帕奇服务器，针对命名空间中的资源，提供了一系列可访问的显示方式。
每一种显示方式通过字节序列表示，序列由媒体类型，字符集，编码方式等信息构成。
任何时候，每一种资源都可能与显示方式有关。
如果有多种显示方式，则资源的显示通过协商解决；每一种显示方式都是一个 **变体**。
前面提到的媒体类型，字符集等，导致变体差异的信息称为协商的 **维度**。

``httpd`` 协商
--------------

为了进行资源协商，服务器需要得到每一种变体的信息（即显示方式）。
可以通过两种方法实现：

* 使用类型映射(即 ``a*.var`` 文件)，显示地指出包含变体信息的文件
* 使用 ``MultiViews`` 搜索，隐式地对文件名做模式匹配，从诸多结果中选择一个。

类型映射文件
^^^^^^^^^^^^

.. note:: 类型映射文件是由服务器提供的

类型映射文件和 ``type-map`` 解析器有关；
为兼容老版的 ``httpd`` 配置，可以用 MIME 类型为 ``application/x-type-map`` 的解析器。
使用解析器特性的前提是，在配置文件中进行设置，将一个文件后缀定义为 ``type-map``；
最好是这样：``AddHandler type-map .var``。
设置之后，``type-map`` 解析器会将 ``.var`` 后缀的文件当做类型映射文件进行解析。

类型映射文件的文件名必须和它们所描述的资源文件相同，只是后面需要添加 ``.var`` 后缀。
在下面的例子中，资源文件名为 ``foo``，因而类型映射文件名为 ``foo.var``。

该文件针对每个可用变体都有对应项；这些项由格式类似 HTTP 头部的连续行构成。
不同变体的对应项由空行隔开，同一项中不允许有空行。
习惯上，映射文件都是以一个合并体作为整体的对应项开始（这不是必须的，如果有也会被忽略）。

类型映射文件中，URI 后面填写的文件名如果是相对路径，则和映射文件的位置相关。
通常，URI 后面的文件和映射文件处在同一个目录下，但这不是必须的。
你可以在 URI 后面填写绝对路径，只要对应文件和类型映射文件处在同一台服务器上即可。

.. code-block:: html

 URI: foo

 URI: foo.en.html
 Content-Type: text/html
 Content-Language: en

 URI: foo.fr.de.html
 Content-Type: text/html;charset=iso-8859-2
 Content-Language: fr, de

注意，对类型映射文件的访问优先于扩展名文件，即使启用 ``MultiViews`` 选项也是如此。
如果变体的起始质量不同，可以用媒体类型的参数 qs 来表示，如下所示：

.. code-block:: html

 URI: foo

 URI: foo.jpeg
 Content-Type: image/jpeg; qs=0.8

 URI: foo.gif
 Content-Type: image/gif; qs=0.5

 URI: foo.txt
 Content-Type: text/plain; qs=0.01

qs 值的范围是 0.000 到 1.000。
注意，如果变体的 qs 值是 0.000，则它永远不会被采用。
不带 qs 参数的变体，其 qs 值为 1.0。
qs 参数表明和其他的变体相比，该变体的相关 **质量**，它和客户端的性能无关。
例如，若要显示一张照片，则 JPEG 的文件的起始质量通常高于 ASCII 文件。
而要展示普通的 ASCII 文件，则 ASCII 文件的起始质量高于 JPEG 文件。
所以，对于依赖资源显示特性的变体，qs 值是很重要的。

``MultiViews``
^^^^^^^^^^^^^^

``MultiViews`` 选项针对的是目录，这意味着可以在 ``httpd.conf`` 的 ``<Directory>``, ``<Location>`` 或 ``<Files>`` 节点中通过 ``Options`` 指令设置；
或者在 ``.htaccess`` 文件中通过 ``Options`` 指令设置（ ``AllowOverride`` 选项必须设置正确）。
注意：``Options All`` 不会开启 ``MultiViews``，只能通过这样的方式开启：``Options MultiViews``。

``MultiViews`` 的效果：如果服务器收到针对 ``/some/dir/foo`` 的请求，且目录 ``/some/dir`` 的 ``MultiViews`` 选项已经开启，但 ``/some/dir/foo`` 不存在，则服务器会在 ``/some/dir`` 目录下查找名为 ``foo.*`` 的文件，并伪造一个类型映射，指出所有这些文件，并给它们设置相同的媒体类型和内容编码，以备客户端通过名称查询。
然后挑选一个最匹配的结果返回给客户端。

如果服务器企图给某个目录建立资源列表，``MultiViews`` 可搜索指令 ``DirectoryIndex`` 指定的文件。
如果配置文件设置了 ``DirectoryIndex index``，且 ``index.html`` 和 ``index.html3`` 都存在，则服务器会在两者之间进行仲裁。
如果两个文件都不存在，但存在 ``index.cgi``，则服务器会运行这个文件。

在遍历指定目录时，如果以上文件中的某个文件没有 ``mod_mime`` 识别的后缀（每个后缀对应了 Charset, Content-Type, Language 或 Encoding 等信息），则结果取决于指令 ``MultiViewsMatch`` 的设置。
这个指令决定了解析器，过滤器及其它扩展类型是否可以参与 ``MultiViews`` 的协商。

.. note:: url 如果映射为服务器上的某个文件目录，实质上是访问该目录的资源列表文件。
 由 ``DirectoryIndex`` 指令指定，默认为 ``index. html``。
 如果这个文件不存在，且该目录应用了 ``Options Indexes``，则模块 ``mod_autoindex`` 会返回一个资源列表。
 否则返回错误 ``403 Forbidden``。
 如果 url 指向的是 ``/``，则访问的是 ``DocumentRoot`` 指令指定的根目录，如 http://192.168.1.2:80

协商方法
--------

``httpd`` 通过类型映射文件或目录文件名匹配（``MultiViews``）获得多个资源变体后，会使用下文提到两种方法之一选取最佳变体。
就为使用 ``httpd`` 的内容协商特性，没有必要了解内容协商的实现细节。
不过，本文其余的部分会为感兴趣的读者讲解协商方法。

有两种协商方式：

1. 正常情况下，使用由服务器驱动的协商算法。
   应用本算法，``httpd`` 有时会修改某一变体的质量因子(``qs``)，以获取更好的结果。
2. 浏览器可以要求服务器使用半透明的内容协商，详见 ``RFC 2295`` 标准。
   通过这种方式，浏览器可以完全自主地决定最佳变体，所得结果取决于浏览器使用的选择算法。
   浏览器也可以可以要求 ``httpd`` 进行半透明协商时采用“远端变体选择算法（``RFC 2296``）。

协商的维度
^^^^^^^^^^

类型映射文件和浏览器发送的请求头中都会用到协商维度：媒体类型，语言，编码方式和字符集。
具体内容列在下面两张表中。

1. 请求头

+------------+-----------------+---------------------+------------+
| dimension  | field           | value               | parameters |
+============+=================+=====================+============+
| Media Type | Accept          | MIME type           | q |
+------------+-----------------+---------------------+------------+
| Language   | Accept-Language | en, fr, zh-cn, etc. | q          |
+------------+-----------------+---------------------+------------+
| Encoding   | Accept-Encoding | Unicode, etc.       | q          |
+------------+-----------------+---------------------+------------+
| Charset    | Accept-Charset  | ISO-8859-1, etc.    | q          |
+------------+-----------------+---------------------+------------+

每个键对应的值可以有多个，用逗号隔开：
		
``Accept-Language: fr; q=1.0, en; q=0.5``

值、不同参数之间用分号隔开。

2. 类型映射文件

+------------+------------------+---------------------+-------------+
| dimension  | field            | value               | parameters  |
+============+==================+=====================+=============+
| Media Type | Content-Type     | MIME type           | qs, charset |
+------------+------------------+---------------------+-------------+
| Language   | Content-Language | en, fr, zh-cn, etc. | ``----``    |
+------------+------------------+---------------------+-------------+
| Encoding   | Content-Encoding | x-gzip, etc.        | ``----``    |
+------------+------------------+---------------------+-------------+

每个键对应的值可以有多个，用逗号隔开；值、多个参数之间用分号隔开。

协商算法
^^^^^^^^

``httpd`` 使用如下算法选择最优变体，该算法不再进行扩展了。
具体内容如下：

1. 检查每个维度的 ``Accept*`` 字段（如 ``Accept-Language``），给每个变体分配一个质量值。
   如果 ``Accept*`` 中的参数指示该变体不可用，则排除。
   如果所有变体都被排除，则进入第 4 阶段；
2. 依次执行以下步骤，通过一步步排除选择最佳变体。
   
   任何变体，只要在某一步中没有被选中，则排除。
   在每一步结束之后，如果只剩下一个变体，则将它作为最佳匹配结果，进入第 3 阶段。
   如果还有多个变体，则继续进行下一步。

   1. 从请求头的 ``Accept`` 字段中取出质量因子 q，乘以变体的 ``Content-type`` 字段中的 qs。
      在所有乘积中选择值最大的变体；
   2. 从变体的 ``Content-language`` 字段中，选择 q 值最大的变体；
   3. 将变体的 ``Content-language`` 和 ``Accept-Language`` 或 ``LanguagePriority`` 列举的语言依次比对，选择最匹配的变体；
   4. 从变体的 ``Content-type`` 字段中，选择 level 值最大的变体（level 表示 ``text/html`` 媒体类型的版本）；
   5. 选择与 ``Accept-Charset`` 字段中的编码方式最匹配的的变体；
   6. 选择 ``Content-type`` 中的 ``charset`` 参数不是 ``ISO-8859-1`` 的变体，如果没有，则选择所有变体。
      媒体类型为 ``text/*`` 的变体如果没有显式地指定字符集，则默认为 ``ISO-8859-1`` 字符集；
   7. 选择编码方式最适合的变体。
      选择编码方式能被浏览器接受的变体；
      若不存在这样的变体，则在编码变体和非编码变体中选择非编码变体；
      如果所有的变体都是编码的或者非编码的，则都选取。
   8. 选择内容最短的变体
   9. 选择剩余变体中的第一个。
      要么在类型映射文件中排在第一个，要么在目录中名称按 ASCII 码顺序排在第一个。

3. 算法已经选出了最佳变体，服务器将它发送给客户端。
   HTTP 的响应头中包含 ``Vary`` 字段，列出了协商维度（浏览器和缓存区可以通过它缓存资源）。
4. 未选中合适的显示方式，返回状态码 406 （``No acceptable representation``），响应体是一个 HTML 文档，其中会列出所有变体名。
   同时 HTTP 响应头的 ``Vary`` 字段也会列出变体的协商维度。

修改质量因子
------------

``httpd`` 有时候会依据上述算法给出的值修改质量因子 qs。
如果浏览器没有提供完整/准确的协商信息，服务器通过修改 qs 值以获得更好的结果。
有一些备受欢迎的浏览器常会发送不完整的 ``Accept`` 字段，导致无法获取正确的协商结果。
如果浏览器发送的信息完整而正确，是不需要做修改的。

媒体类型和通配符
^^^^^^^^^^^^^^^^

``Accept`` ：指定浏览器对媒体类型的偏好。
可以使用通配符表示多种类型，如 ``image/*`` 或 ``*/*``。
因此 ``Accept: image/*, */*`` 表示接受以 ``image/`` 开头的媒体类型和任意其它类型。
一些浏览器常常将能解析的类型显式地放在前面，后面跟上通配符。
例如：``Accept: text/html, text/plain, image/gif, image/jpeg, */*``。
其意图是告诉服务器它们更希望使用前面列出的媒体类型，但其它类型也可以接受。
显式地标出质量值，可以明确告知浏览器真正的需求：

``Accept: text/html, text/plain, image/gif, image/jpeg, */*; q=0.01``

浏览器的需求类型没有标明质量因子，因而采用默认值 1.0（即最高值）。
通配符 ``*/*`` 的质量因子只给了 0.01，所以如果没有变体符合显示列出的媒体类型，就选择其它类型的变体。

如果 ``Accept`` 没有设定 q 值，则 ``httpd`` 会仿照期望的做法将 ``*/*`` （有的话）的 q 值设定为 0.01；
将 ``type/*`` 的 q 值设为 0.02（因此该类型的偏好程度比 ``*/`` 高些）。
如果 ``Accept`` 中的所有媒体类型都有一个 q 值，那么前面说的默认值就用不上了。
因此，在客户端请求中附带明确信息可以让服务器按照浏览器的意愿工作。

语言协商异常
^^^^^^^^^^^^

``httpd 2.0`` 中引进了新属性，进行语言协商时，如果没有找到匹配变体，则协商算法会抛出异常，给出详细回溯信息。

客户端请求网页时，如果服务器找不到匹配 ``Accept-Language`` 字段的网页，服务器会发 ``No Acceptable Variant`` / ``Multiple Choices`` 响应给客户端。
为避免服务器发这些错误信息，可能需要对 ``httpd`` 进行设置，在上述情况下是否忽略 ``Accept-Language``，并提供一个不能完全符合用户请求的文档。
通过指令 ``ForceLanguagePriority``，可以改写错误响应信息，同时依靠 ``LanguagePriority`` 指令代替服务器的判断。

在没有找到合适语言变体的情况下，服务器也会设法匹配语言的子集。
例如，如果客户端要求语言类型是 ``en-GB`` （即英式英语），
根据 ``HTTP/1.1`` 的标准，服务器不能只匹配该语言类型，而不匹配类型为 ``en`` 的文档。
（注意，``Accept-Language`` 中有 ``en-GB`` 没有 ``en`` 几乎可认定是配置错误。
因为，读者懂英式英语，却不懂一般英语，是不可能的。
不幸的是，许多客户端请求采用了类似的配置。）
然而，服务器在找不到其它匹配语言而准备返回 ``No Acceptable Variant`` 错误响应，
或者 ``LanguagePriority`` 对应的回溯信息的情况下，
会忽略子集匹配规范而只匹配 ``en-GB`` 不匹配 ``en``。
``httpd`` 暗中会把客户端能接受的语言的父语言以非常低的 q 值列举并添加到变体中。
但需要注意的是，如果客户端请求为 ``en-GB; q=0.9, fr;q=0.8``，
且服务器存在语言类型指定为 ``en`` 或 ``fr`` 的文档，则 ``fr`` 文档会被选中。
这么做是为了和 ``HTTP/1.1`` 说明书保持一致，同时与配置正确的客户端开始高效地协同工作。

为支持一些高级技术（如曲奇和特殊 url 路径），以挑选用户偏好的语言，从 ``httpd 2.0.47`` 开始，模块 ``mod_negotiation`` 能够识别环境变量 ``prefer-language``。
如果该环境变量存在，且给出了合适的语言标签，``mod_negotiation`` 会依据它选择匹配的变体。
如果找不到匹配结果，再进行正常的内容协商过程。

.. code-block:: html

 SetEnvIf Cookie "Language=(.+)" prefer-language=$1
 Header append Vary cookie

半透明协商的扩展
----------------

``httpd`` 对半透明内容协商进行了扩展。
在变体列表中增加一个新的元素 ``encoding``，用于指出某些进行了特殊内容编码的变体。
``RVSA/1.0`` 算法（RFC 2296）扩展之后，可以识别类型映射列表中已经编码的变体，
并将它们做为候选变体，无论它们的编码方式是否和 ``Accept-Encoding`` 字段符合。
``RVSA/1.0`` 算法在选择最佳变体时，不对质量因子进行四舍五入。

关于超链接和命名约定
--------------------

在使用语言协商时，可以选择不同的命名约定，
因为文件可以有多个扩展名，扩展名顺序一般是无关紧要的。

一个典型的文件拥有一个 MIME 类型扩展名（例如 ``.html``），
一个编码扩展名（例如：``.gz``），
以及一个语言扩展名（例如：``en``）。

例如：

* ``foo.en.html``
* ``foo.html.en``
* ``foo.en.html.gz``
  
下表中给出了更多文件名的例子：

+----------------+----------------------------+---------------------+
| 文件名         | 有效超链接                 | 无效超链接          |
+================+============================+=====================+
| foo.html.en    | foo, foo.html              | -                   |
+----------------+----------------------------+---------------------+
| foo.en.html    | foo                        | foo.html            |
+----------------+----------------------------+---------------------+
| foo.html.en.gz | foo, foo.html              | foo.gz, foo.html.gz |
+----------------+----------------------------+---------------------+
| foo.gz.html.en | foo, foo.gz, foo.gz.html   | foo.html            |
+----------------+----------------------------+---------------------+
| foo.html.gz.en | foo, foo.html, foo.html.gz | foo.gz              |
+----------------+----------------------------+---------------------+

通过上表可以看出，在超链接中允许使用不带任何后缀的名称（如 ``foo``）。
好处是，可以隐藏文档 ``rsp.file`` 的真正类型。
在将来修改文档类型时（从 ``html`` 变为 ``shtml`` 或者 ``cgi`` 类型）可以不用改变超链接。

如果你想在超链接中接续使用 MIME 类型（如 ``foo.html``），则语言扩展名必须出现在 MIME 扩展名右边（有编码扩展名的话，需要加上）（例如：``foo.html.en``）。

关于缓存
--------

如果客户端缓存了变体，则会将请求的 url 和该变体关联起来。
下一次收到相同的 url 请求之后，会直接从缓存中的获取响应。
如果服务器上的资源是可以协商的，首次请求的变体在客户端缓存后，
后续请求只要命中缓存就不再经过服务器协商，导致需要重新协商的请求得不到正确的响应结果。
为了防止出现这个问题，``httpd`` 通过 HTTP/1.0 客户端将所有协商的响应标记为不可缓存。
``httpd`` 也支持 HTTP/1.1 的客户端请求，该协议允许客户端缓存协商响应。

对于所有 HTTP/1.0 的可信任客户端（浏览器或缓存）发出的请求，指令 ``CacheNegotiateDocs`` 允许将协商的响应进行缓存。
该指令可以出现在 ``server config`` 或者 ``virtual host`` 应用场景中，没有任何参数。
它对来自 HTTP/1.1 客户端的请求不起作用。

对于 HTTP/1.1 客户端，``httpd`` 在响应头的 ``Vary`` 字段中给出响应的协商维度。
缓存通过这些信息来决定随后的请求是否能直接从本地副本中获取响应。
要想缓存直接使用本地副本，而不用关心协商维度，可以设置环境变量 ``force-no-vary``。