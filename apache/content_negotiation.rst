内容协商
========

阿帕奇 ``httpd`` 服务器支持内容协商，``HTTP/1.1`` 说明书对内容协商有详细介绍。
内容协商可以根据浏览器对媒体类型，语言，字符集以及编码方式等方面的不同偏好，选用最好的方式显示资源。
它还具有若干特性，针对浏览器发送的协商信息内容不全的请求，采取更加智能的方式进行解析。

内容协商功能由模块 ``mod_negotiation`` 实现，默认情况下该模块在服务器编译的时候静态加载。

关于内容协商
------------

资源有多种不同的显示方式，比如使用不同语言或不同媒体类型或它们之间的组合。
如何选择更合适的显示方式呢？
一种方法是向用户提供目录列表，由用户自己选择。
但通常都是由服务器自动选择的，只要浏览器在每个请求中添加相关信息，表明它对资源显示方式的偏好就可以了。
例如，某个浏览器更希望看到用法语表述的文字信息，不行的话才用英语表述。
浏览器将他们的偏好放在请求头中。
如果要求仅用法语表述，则浏览器需要在请求头中加上``Accept-Language: fr``。
注意，这种偏好设置，只用于需要从多个不同语言的表示形式中挑选一个的场合。

一个更复杂的请求示例：浏览器可以接受法语和英语，但是偏向于法语。
接受多种媒体类型，与普通文本或者其他文本类型相比，更偏向于 HTML 类型。
与其他媒体类型相比，更偏向于 GIF 或 JPEG 图片，当然没有选择余地时，才选择剩下的类型。

.. code-block:: HTML

 Accept-Language: fr; q=1.0, en; q=0.5
 Accept: text/html; q=1.0, text/*; q=0.8, image/gif; q=0.6, image/jpeg; q=0.6, image/*; q=0.5, */*; q=0.1

``httpd`` 支持由“服务器驱动”的内容协商，关于这点，在 ``HTTP/1.1`` 说明书中有具体定义。
它完全支持在请求头中加上 ``Accept``, ``Accept-Language``, ``Accept-Charset`` 以及 ``Accept-Encoding`` 设置。
``httpd`` 也支持半透明的内容协商；半透明内容协商还处在实验阶段，``RFC 2295/2296`` 协议标准对它进行了定义。
但 ``httpd`` 不支持这些协议中定义的“特征协商”。

资源是 URI 指定的概念化实体。
HTTP 服务器，如阿帕奇服务器，针对命名空间中的资源，提供了一系列可访问的显示方式。
每一种显示方式通过字节序列表示，序列由媒体类型，字符集，编码方式等信息构成。
任何时候，每一种资源都可能与显示方式有关。
如果有多种显示方式，则资源的显示通过协商解决；每一种显示方式都是一个 **变体**。
前面提到的媒体类型，字符集等，导致变体差异的信息称为协商的 **维度**。

``httpd`` 协商
--------------

为了进行资源协商，服务器需要得到每一种变体的信息（即显示方式）。
可以通过两种方法实现：

* 使用类型映射(即 ``a*.var`` 文件)，显示地指出包含变体信息的文件
* 使用 ``MultiViews`` 搜索，隐式地对文件名做模式匹配，从诸多结果中选择一个。

类型映射文件
^^^^^^^^^^^^

.. note:: 类型映射文件是由服务器提供的

类型映射文件和 ``type-map`` 解析器有关；
为兼容老版的 ``httpd`` 配置，可以用 MIME 类型为``application/x-type-map`` 的解析器。
使用解析器特性的前提是，在配置文件中进行设置，将一个文件后缀定义为 ``type-map``；
最好是这样：``AddHandler type-map .var``。
设置之后，``type-map`` 解析器会将 ``.var`` 后缀的文件当做类型映射文件进行解析。

类型映射文件的文件名必须和它们所描述的资源文件相同，只是后面需要添加 ``.var`` 后缀。
在下面的例子中，资源文件名为 ``foo``，因而类型映射文件名为 ``foo.var``。

该文件针对每个可用变体都有对应项；这些项由格式类似 HTTP 头部的连续行构成。
不同变体的对应项由空行隔开，同一项中不允许有空行。
习惯上，映射文件都是以一个合并体作为整体的对应项开始（这不是必须的，如果有也会被忽略）。

类型映射文件中，URI 后面填写的文件名如果是相对路径，则和映射文件的位置相关。
通常，URI 后面的文件和映射文件处在同一个目录下，但这不是必须的。
你可以在 URI 后面填写绝对路径，只要对应文件和类型映射文件处在同一台服务器上即可。

.. code-block:: html

 URI: foo

 URI: foo.en.html
 Content-type: text/html
 Content-language: en

 URI: foo.fr.de.html
 Content-type: text/html;charset=iso-8859-2
 Content-language: fr, de

注意，对类型映射文件的访问优先于扩展名文件，即使启用 ``MultiViews`` 选项也是如此。
如果变体的起始质量不同，可以用媒体类型的参数 qs 来表示，如下所示：

.. code-block:: html

 URI: foo

 URI: foo.jpeg
 Content-type: image/jpeg; qs=0.8

 URI: foo.gif
 Content-type: image/gif; qs=0.5

 URI: foo.txt
 Content-type: text/plain; qs=0.01

qs 值的范围是 0.000 到 1.000。
注意，如果变体的 qs 值是 0.000，则它永远不会被采用。
不带 qs 参数的变体，其 qs 值为 1.0。
qs 参数表明和其他的变体相比，该变体的相关 **质量**，它和客户端的性能无关。
例如，若要显示一张照片，则 JPEG 的文件的起始质量通常高于 ASCII 文件。
而要展示普通的 ASCII 文件，则 ASCII 文件的起始质量高于 JPEG 文件。
所以，对于依赖资源显示特性的变体，qs 值是很重要的。

``MultiViews``
^^^^^^^^^^^^^^

``MultiViews`` 选项针对的是目录，这意味着可以在 ``httpd.conf`` 的 ``<Directory>``, ``<Location>`` 或 ``<Files>`` 节点中通过 ``Options`` 指令设置；
或者在 ``.htaccess`` 文件中通过 ``Options`` 指令设置（ ``AllowOverride`` 选项必须设置正确）。
注意：``Options All`` 不会开启 ``MultiViews``，只能通过这样的方式开启：``Options MultiViews``。

``MultiViews`` 的效果：如果服务器收到针对 ``/some/dir/foo`` 的请求，且目录 ``/some/dir`` 的 ``MultiViews`` 选项已经开启，但 ``/some/dir/foo`` 不存在，则服务器会在 ``/some/dir`` 目录下查找名为 ``foo.*`` 的文件，并伪造一个类型映射，指出所有这些文件，并给它们设置相同的媒体类型和内容编码，以备客户端通过名称查询。
然后挑选一个最匹配的结果返回给客户端。

如果服务器企图给某个目录建立资源列表，``MultiViews`` 可搜索指令 ``DirectoryIndex`` 指定的文件。
如果配置文件设置了 ``DirectoryIndex index``，且 ``index.html`` 和 ``index.html3`` 都存在，则服务器会在两者之间进行仲裁。
如果两个文件都不存在，但存在 ``index.cgi``，则服务器会运行这个文件。

在遍历指定目录时，如果以上文件中的某个文件没有 ``mod_mime`` 识别的后缀（每个后缀对应了 Charset, Content-Type, Language 或 Encoding 等信息），则结果取决于指令 ``MultiViewsMatch`` 的设置。
这个指令决定了解析器，过滤器及其它扩展类型是否可以参与 ``MultiViews`` 的协商。

.. note:: url 如果映射为服务器上的某个文件目录，实质上是访问该目录的资源列表文件。
 由 ``DirectoryIndex`` 指令指定，默认为 ``index. html``。
 如果这个文件不存在，且该目录应用了 ``Options Indexes``，则模块 ``mod_autoindex`` 会返回一个资源列表。
 否则返回错误 ``403 Forbidden``。
 如果 url 指向的是 ``/``，则访问的是 ``DocumentRoot`` 指令指定的根目录，如 http://192.168.1.2:80

协商方法
--------

``httpd`` 通过类型映射文件或目录文件名匹配（``MultiViews``）获得多个资源变体后，会使用下文提到两种方法之一选取最佳变体。
就为使用 ``httpd`` 的内容协商特性，没有必要了解内容协商的实现细节。
不过，本文其余的部分会为感兴趣的读者讲解协商方法。

有两种协商方式：

1. 正常情况下，使用由服务器驱动的协商算法。
   应用本算法，``httpd`` 有时会修改某一变体的质量因子(``qs``)，以获取更好的结果。
2. 浏览器可以要求服务器使用半透明的内容协商，详见 ``RFC 2295`` 标准。
   通过这种方式，浏览器可以完全自主地决定最佳变体，所得结果取决于浏览器使用的选择算法。
   浏览器也可以可以要求 ``httpd`` 进行半透明协商时采用“远端变体选择算法（``RFC 2296``）。

协商的维度
^^^^^^^^^^

+----------+-----------------+---------------+----------------+--------+
| 维度     | 键              | 值            | 参数           | 值个数 |
+==========+=================+===============+================+========+
| 媒体类型 | Accept          | mime          | q, charset, qs | 任意   |
+----------+-----------------+---------------+----------------+--------+
| 语言     | Accept-Language | 如 en,fr      | q              | 任意   |
+----------+-----------------+---------------+----------------+--------+
| 编码     | Accept-Encoding | 如 iso-8859-2 | q              | 1      |
+----------+-----------------+---------------+----------------+--------+
| 字符集   | Accept-Charset  | 如 utf-8      | q              | 1      |
+----------+-----------------+---------------+----------------+--------+

.. note:: 以上键值对是由浏览器在请求头中给出的，
 反应了浏览器对媒体类型，语言，编码方式以及字符集的偏好。
 附带的参数和值用 ``;`` 隔开，值和值之间用逗号隔开。

协商算法
^^^^^^^^

``httpd`` 使用如下算法选择最好的变体，该算法不能做进一步的设置。
具体内容如下：

1. 检查每个维度的 ``Accept*`` 字段，给每个变体分配一个质量值。
   如果 ``Accept*`` 值表明该变体不可用，则排除该变体。
   如果所有变体都被排除，则进入第 4 阶段；
2. 通过排除法选择最佳变体。
   依次执行以下步骤。
   任何变体，只要在某一步中没有被选中，则排除。
   在每一步结束之后，如果只剩下一个变体，则将它作为最佳匹配结果并进入第 3 阶段。
   如果还有多个变体，则继续进行下一步。

   1. 从请求头的 ``Accept`` 字段中取出质量因子 q，乘以变体的 ``Content-type`` 字段中的 qs。
      在所有乘积中选择值最大的变体；
   2. 从变体的 ``Content-language`` 字段中，选择 q 值最大的变体；
   3. 将变体的 ``Content-language`` 和 ``Accept-Language`` 或 ``LanguagePriority`` 列举的语言依次比对，选择最匹配的变体；
   4. 从变体的 ``Content-type`` 字段中，选择 level 值最大的变体（level 表示 ``text/html`` 媒体类型的版本）；
   5. 选择与 ``Accept-Charset`` 字段中的编码方式最匹配的的变体；
   6. 选择 ``Content-type`` 中的 ``charset`` 参数不是 ``ISO-8859-1`` 的变体，如果没有，则选择所有变体。
      媒体类型为 ``text/*`` 的变体如果没有显式地指定字符集，则默认为 ``ISO-8859-1`` 字符集；
   7. 选择编码方式最适合的变体。
      选择编码方式能被浏览器接受的变体；
      若不存在这样的变体，则在编码变体和非编码变体中选择非编码变体；
      如果所有的变体都是编码的或者非编码的，则都选取。
   8. 选择内容最短的变体
   9. 选择剩余变体中的第一个。
      要么在类型映射文件中排在第一个，要么在目录中名称按 ASCII 码顺序排在第一个。

3. 算法已经选出了最佳变体，服务器将它发送给客户端。
   HTTP 的响应头中的 ``Vary`` 字段显示了协商的维度（浏览器和缓存区可以通过它缓存资源）。
4. 没有选中任何的变体（因为没有合适的），返回状态码 406 （“没有合适的资源显示”），响应体是一个 HTML 文档，其中会列出所有变体。
   同时 HTTP 响应头的 ``Vary`` 字段也会表明所有协商维度。

修改质量因子
------------

``httpd`` 在严格执行上文中的算法时，有时候会依据算法给出的值修改质量因子 qs。
如果浏览器没有提供完整的或者准确的信息，修改 qs 可以取得更好的结果。
很多时候，某些常用的浏览器发送的 ``Accept`` 头字段会导致选取变体出错。
如果浏览器发送的信息完整而且正确，是不需要做修改的。

媒体类型和通配符
^^^^^^^^^^^^^^^^

``Accept`` ：指定浏览器对媒体类型的偏好。
可以使用通配符表示多种类型，如 ``image/*`` 或 ``*/*``。
因此 ``Accept: image/*, */*`` 表示任意以 ``image/`` 开始的媒体类型都是浏览器接受的类型。