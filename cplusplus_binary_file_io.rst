C++读写二进制文件
=================

典型的 C++ 文件读写通过以下 IO 流对象实现：

* ifstream 只负责文件读操作
* ofstream 只负责文件写操作
* fstream 负责文件的读写操作
  
.. note:: 
 这些类的声明在头文件 ``<fstream.h>``。
 正常情况下，对于二进制文件的 I/O 操作，不要使用文本操作符 ``<<`` 和 ``>>``。

前面提到一个“流”的概念，可以形象地描述文件的读写操作。
因为计算机存储数据采用的是二进制格式，将数据当做二进制串像水流一样“流入”或者“流出”文件。
根据存储单位的不同，有比特流和字节流。
因为文件的读写都是以字节为单位的，所以本文说到的流都是字节流。

每个打开的文件有两个指针：

* 当前读指针，指定文件将要读取的字节的位置
* 当前写指针，指定下一个字节将要放置的位置
  
这两个指针是独立的，都可以指向文件的任意位置。

打开文件
--------

文件流对象可以使用两种方法定义。

.. code-block:: C++
  :linenos:
  
  ifstream in("test.txt", ios::in | ios::binaray) // 隐式定义
  ifstream in;
  in.open("test.txt", ios::in | ios::binaray) // 显示定义

如果是文本文件，一般会省略第二个参数，默认即为读写文本文件；
如果是二进制文件，则需要显示声明 ``ios::binaray``。

如果是 GNU g++ 编译器，则 ``ifstream`` 对象的定义不要使用读写标志位；
因为 GNU libg++ 有 bug，无法正确解析标志位。
如果是 Unix 操作系统，则所有流类对象的定义都可以省略标志位，
如果是 MS-DOS 的 g++，则使用流类 ``ifstream`` 构建对象。

.. warning:: 上一段内容仅针对 g++ 编译器

读文件
------

使用 ``read()`` 方法：

.. code-block:: C++
  :linenos:

  istream& read(char*, int);

该函数从给定流对象中获取指定字节数的数据，并存储到第一个参数指定的内存空间中，
读取位置是从读指针指定的位置。
该内存需要用户自己创建和管理，而且用户必须保证空间足够。

.. warning:: 读取的内容和文件中存储的二进制数据完全一致，不会对数据进行任何的转换处理。
 比如，将回车换行符转为换行符，也不会在数据末尾添加串结束符 '\0'

如果读取出错，流对象会进入出错状态，此时流对象不可用，再调用 ``read()`` 会失败。
但可以调用以下方法：

* ``gcount()`` 计算已经读取的字符数；
* ``clear()`` 重置流对象，变为可用状态
  
重置读指针
----------

.. code-block:: C++
  :linenos:

  istream& seekg(streampos pos); // pos表示绝对偏移

获取读指针
----------

.. code-block:: C++
  :linenos:
  
  streampos tellg(void)

写文件
------

和读文件差不多：

.. code-block:: C++
  :linenos:

  ostream& write(const char* , int);

将指定内存数据写入文件指定位置。
如果指定位置是文件末尾，则文件内容会扩充；
如果指定位置不是文件末尾，则指定位置之后的内容会被重写。
写入的数据不会被解析，也就是说对于换行符，不会自动增加回车符。

如果写入失败，则流对象进入出错状态，不能进行任何的写操作

重置写指针
----------

.. code-block:: C++
  :linenos:

   ostream& seekp(streampos pos);

关闭文件
--------

.. code-block:: C++
  :linenos:

  void close()

文件读写完毕，一定要记得关闭。